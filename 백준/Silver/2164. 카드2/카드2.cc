#include<iostream>
#include<queue>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    queue<int> myQueue;
    int N;
    cin >> N;
    
    for(int i = 1; i <= N; i++){ //카드 저장
        myQueue.push(i);
    }
    
    while(myQueue.size() > 1) { // queue에 1개 가 남을때 까지
        myQueue.pop();  // 맨 위 카드를 버린다.
        myQueue.push(myQueue.front());  // 큐 맨앞에 있는 카드를 얻고, 이 카드를 큐의 맨 아래에 위치한 카드 밑으로 이동시킨다.
        myQueue.pop(); 
        //위와 같이 작성되면, "제일 위에 있는 카드를 제거후 그 카드를 제일 아래로 옮기고 다시 제거 하는 작업을 반복"
    }
    cout << myQueue.front();
    
    return 0;
}

/*
1. 입력값 cin >> N = 6이 입력되면 
2. for문에서 카드를 저장한다. i가 1로 초기화되서 queue 1번 인덱스에 디버깅 해보면 
[0] = 0x00000001
[1] = 0x00000002
[2] = 0x00000003
[3] = 0x00000004
[4] = 0x00000005
[5] = 0x00000006
이런식으로 들어가 있다. 총 6번을 다 돌고 나서 

3. while문으로 들어간다. myQueue.size() 큐에 들어가 있는 사이즈 0~5 번 배열 에 1이 남을때까지 반복한다. 
4. myQueue.pop(); 가장 앞에있는 0번 인덱스 에 1이 pop된다.
5. myQueue.push(myQueue.front()); 가장 앞에 있는 인덱스 1번이 이제 0번인덱스가 되고 값 2가 5개의 배열만 남았으니
[4]번 인덱스에 2가 넘어간다. 
즉 
1번째
[0] = 0x00000002
[1] = 0x00000003
[2] = 0x00000004
[3] = 0x00000005
[4] = 0x00000006
=>
[0] = 0x00000003
[1] = 0x00000004
[2] = 0x00000005
[3] = 0x00000006
[4] = 0x00000002
이런식으로 된다. 이 과정을 1개가 남을 때 까지 반복한다. 

2번째
pop()
[0] = 0x00000004
[1] = 0x00000005
[2] = 0x00000006
[3] = 0x00000002
=>
push(front())
[0] = 0x00000005
[1] = 0x00000006
[2] = 0x00000002
[3] = 0x00000004

3번째
pop()
[0] = 0x00000006
[1] = 0x00000002
[2] = 0x00000004

push()
[0] = 0x00000002
[1] = 0x00000004
[2] = 0x00000006

4번째
pop()
[0] = 0x00000004
[1] = 0x00000006

push
[0] = 0x00000006
[1] = 0x00000004

5번째
[0] = 0x00000004

1개가 남아 더이상 돌지 않고 while문을 빠져나온다. 
*/